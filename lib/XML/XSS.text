NAME
    XML::XSS - a XML stylesheet system

SYNOPSIS
        use XML::XSS;

        my $xss = XML::XSS->new;

        $xss->set( pod => { 
            pre => "=pod\n", 
            post => "=cut\n" 
        } );

        $xss->set( section => { 
            pre => \&pre_section 
        } );

        sub pre_section {
            my ( $self, $node, $args ) = @_;

            return "=head1 " . $node->findvalue( '@title' ) . "\n\n";
        }

        print $xss->render( <<'END_XML' );
        <pod><section title="NAME">XML::XSS - a XML stylesheet system</section>
            ...
        </pod>
        END_XML

DESCRIPTION
    "XML::XSS" is a XML stylesheet system loosely similar to CSS and XSLT.
    Rendering actions are declared for the different elements of a XML
    document, which are then applied against one or many XML documents.

    "XML::XSS" is a rewrite of XML::XPathScript, which was initially part of
    the AxKit framework.

Rules Rendering Attributes
    Unless specified otherwise, the rendering attributes of the rules accept
    either a scalar, that will be used as-is, or a reference to a sub, that
    will be evaluated in the context of the document node being rendered.

    Upon execution, the sub references will be passed three parameters: the
    invoking rule, the XML::LibXML node it is rendering and the arguments
    ref passed to "render()". The return value of the sub will be used as
    the .

        $css->set( 'foo' => {
            pre => '[[[',         
            post => sub {        
                my ( $self, $node, $args ) = @_;
                return $node->findvalue( '@bar' );
            }
        } );

TUTORIAL
    So, how to use "XML::XSS"? First, you have to create a stylesheet

        my $xss = XML::XSS->new;

    Then, you have to define the rules dictating how the different XML
    elements are to be rendered.

        $xss->set( '#document' => {
            pre => 'BEGIN',
            post => 'END',
        } );

    And then you apply the stylesheet against a document, which can be
    either a string

        $xss->render( '<doc><foo>...</foo></doc>' );

    or an XML::LibXML node

        my $doc = XML::LibXML->load_xml( location => 'doc.xml' );
        $xss->render( $doc );

  Terminology
    The XML::XSS object is the stylesheet.

    The stylesheet is composed of rules, which dictate how to process the
    different nodes of a XML document. There are 6 different types of rules:
    XML::XSS::Document, XML::XSS::Text, XML::XSS::Comment,
    XML::XSS::ProcessingInstruction and XML::XSS::Element.

    Rules have rendering attributes.

  catchall_element
    Returns the catch-all rule, which is applied to all the element nodes
    that aren't explicitly matched by an element rule.

    If using "set()" or "element()", the catch-all element can be accessed
    via "*".

        # change all tags to <unknown> except for <foo>
        $xss->set( 'foo' => { showtag => 1 } );
        $xss->set( '*' => { rename => 'unknown' } );

  document
    Returns the document rule. Note that this matches against the
    "XML::LibXML::Document" node, not the root element node of the document.

  stash
    Returns a stash (an hashref) that is accessible to all the rules and can
    be used to pass information between them during the rendering of a
    document.

        $xss->set( section => {  
            intro => \&section_title,
        } );

        # turns <section title="blah"> ...
        # into 1. blah
        sub section_title {
            my ( $self, $node, $args ) = @_;

            my $section_nbr = $self->stash->{section_nbr}++;

            return $section_nbr . ". " . $node->findvalue( '@title' );
        }

    By default, the stash is cleared when rendering a document. To change
    this behavior, see "use_clean_stash" in XML::XSS::Document.

  clear_stash
    Clears the stylesheet's stash.

  element( $name )
    Returns the XML::XSS::Element node associated to the tag $name.

DOCUMENT NODE NAMES
  set( $name, \%attrs )
    Sets attributes for a rendering node.

    The $name can be an XML element name, or one of the special keywords
    "#document", "#text", "#comment", "#processing_instruction" or "*",
    which will resolve to the corresponding rendering object.

        $xss->set( 'foo' => { rename => 'bar' } );
        # same as $xss->element('foo')->set( rename => 'bar' );

        $xss->set( '#text' => { filter => { uc shift } } );
        # same as $xss->text->set( filter => { uc shift } );

